<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TypeRig Glyph Viewer</title>
<style>
	/* -- Fonts -------------------------------------------------- */
	@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&family=DM+Sans:wght@400;500;600;700&display=swap');

	/* -- Variables ---------------------------------------------- */
	:root {
		--bg-primary: #1a1a1e;
		--bg-secondary: #222226;
		--bg-tertiary: #2a2a2e;
		--bg-hover: #333338;
		--border: #3a3a40;
		--border-subtle: #2e2e34;
		--text-primary: #e8e8ec;
		--text-secondary: #9898a0;
		--text-dim: #686870;
		--accent: #5b9def;
		--accent-dim: #3a6fb0;
		--accent-bg: rgba(91,157,239,0.08);
		--node-on: #e8e8ec;
		--node-off: #5b9def;
		--node-smooth: #50c878;
		--node-selected: #ff6b6b;
		--handle-line: rgba(91,157,239,0.45);
		--outline-fill: rgba(200,200,210,0.12);
		--outline-stroke: #c8c8d2;
		--metric-line: rgba(255,120,80,0.35);
		--metric-line-adv: rgba(91,157,239,0.45);
		--baseline: rgba(255,120,80,0.25);
		--anchor-color: #ff6b6b;
		--xml-tag: #5b9def;
		--xml-attr: #c792ea;
		--xml-value: #c3e88d;
		--xml-comment: #686870;
		--xml-highlight: rgba(91,157,239,0.15);
		--xml-highlight-border: rgba(91,157,239,0.5);
		--scrollbar-thumb: #3a3a40;
		--scrollbar-track: transparent;
	}

	/* -- Reset -------------------------------------------------- */
	*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

	body {
		font-family: 'DM Sans', sans-serif;
		background: var(--bg-primary);
		color: var(--text-primary);
		height: 100vh;
		overflow: hidden;
		user-select: none;
		-webkit-font-smoothing: antialiased;
	}

	/* -- Scrollbar ---------------------------------------------- */
	::-webkit-scrollbar { width: 6px; height: 6px; }
	::-webkit-scrollbar-track { background: var(--scrollbar-track); }
	::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px; }
	::-webkit-scrollbar-thumb:hover { background: #4a4a50; }

	/* -- Layout ------------------------------------------------- */
	#app {
		display: grid;
		grid-template-rows: auto 1fr auto;
		height: 100vh;
	}

	/* -- Toolbar ------------------------------------------------ */
	#toolbar {
		display: flex;
		align-items: center;
		gap: 6px;
		padding: 6px 12px;
		background: var(--bg-secondary);
		border-bottom: 1px solid var(--border);
		z-index: 10;
	}

	#toolbar .logo {
		font-family: 'JetBrains Mono', monospace;
		font-weight: 600;
		font-size: 12px;
		color: var(--accent);
		letter-spacing: 0.5px;
		margin-right: 8px;
		white-space: nowrap;
	}

	#toolbar .separator {
		width: 1px;
		height: 20px;
		background: var(--border);
		margin: 0 4px;
	}

	.tb-btn {
		display: inline-flex;
		align-items: center;
		gap: 5px;
		padding: 5px 10px;
		background: transparent;
		border: 1px solid transparent;
		border-radius: 4px;
		color: var(--text-secondary);
		font-family: 'DM Sans', sans-serif;
		font-size: 12px;
		cursor: pointer;
		transition: all 0.15s;
		white-space: nowrap;
	}

	.tb-btn:hover {
		background: var(--bg-hover);
		color: var(--text-primary);
		border-color: var(--border);
	}

	.tb-btn.active {
		background: var(--accent-bg);
		color: var(--accent);
		border-color: var(--accent-dim);
	}

	.tb-btn svg { width: 14px; height: 14px; }

	.tb-group {
		display: flex;
		align-items: center;
		gap: 2px;
	}

	.tb-spacer { flex: 1; }

	#glyph-info {
		font-family: 'JetBrains Mono', monospace;
		font-size: 11px;
		color: var(--text-dim);
		margin-left: 8px;
	}

	#glyph-info span { color: var(--text-secondary); }

	/* -- Main area ---------------------------------------------- */
	#main {
		display: grid;
		grid-template-columns: 1fr;
		overflow: hidden;
		position: relative;
	}

	#main.split { grid-template-columns: 1fr 1fr; }

	/* -- Canvas ------------------------------------------------- */
	#canvas-wrap {
		position: relative;
		overflow: hidden;
		background: var(--bg-primary);
		cursor: grab;
	}

	#canvas-wrap:active { cursor: grabbing; }

	#glyph-canvas {
		position: absolute;
		top: 0; left: 0;
		width: 100%;
		height: 100%;
	}

	/* -- XML Panel ---------------------------------------------- */
	#xml-panel {
		display: none;
		flex-direction: column;
		background: var(--bg-secondary);
		border-left: 1px solid var(--border);
		overflow: hidden;
	}

	#main.split #xml-panel { display: flex; }

	#xml-panel-header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		padding: 6px 12px;
		background: var(--bg-tertiary);
		border-bottom: 1px solid var(--border);
		font-size: 11px;
		font-family: 'JetBrains Mono', monospace;
		color: var(--text-dim);
	}

	#xml-content {
		flex: 1;
		overflow: auto;
		padding: 12px;
		font-family: 'JetBrains Mono', monospace;
		font-size: 12px;
		line-height: 1.65;
		tab-size: 2;
		white-space: pre;
		color: var(--text-secondary);
		cursor: text;
		user-select: text;
	}

	#xml-content .xml-line {
		display: block;
		padding: 0 4px;
		border-left: 2px solid transparent;
		border-radius: 2px;
		transition: background 0.12s, border-color 0.12s;
	}

	#xml-content .xml-line:hover {
		background: rgba(255,255,255,0.02);
	}

	#xml-content .xml-line.highlighted {
		background: var(--xml-highlight);
		border-left-color: var(--xml-highlight-border);
	}

	#xml-content .xml-line.clickable { cursor: pointer; }

	.xt { color: var(--xml-tag); }         /* tag names */
	.xa { color: var(--xml-attr); }        /* attribute names */
	.xv { color: var(--xml-value); }       /* attribute values */
	.xp { color: var(--text-dim); }        /* punctuation < > / = */
	.xc { color: var(--xml-comment); }     /* comments */

	/* -- Status bar --------------------------------------------- */
	#statusbar {
		display: flex;
		align-items: center;
		gap: 16px;
		padding: 4px 12px;
		background: var(--bg-secondary);
		border-top: 1px solid var(--border);
		font-family: 'JetBrains Mono', monospace;
		font-size: 10px;
		color: var(--text-dim);
	}

	#statusbar .status-item { display: flex; align-items: center; gap: 4px; }
	#statusbar .status-label { color: var(--text-dim); }
	#statusbar .status-value { color: var(--text-secondary); }

	/* -- Drop overlay ------------------------------------------- */
	#drop-overlay {
		display: none;
		position: fixed;
		inset: 0;
		background: rgba(26,26,30,0.92);
		z-index: 100;
		justify-content: center;
		align-items: center;
		flex-direction: column;
		gap: 12px;
	}

	#drop-overlay.visible { display: flex; }

	#drop-overlay .drop-icon {
		width: 56px; height: 56px;
		border: 2px dashed var(--accent-dim);
		border-radius: 12px;
		display: flex;
		align-items: center;
		justify-content: center;
	}

	#drop-overlay .drop-icon svg { width: 24px; height: 24px; color: var(--accent); }

	#drop-overlay .drop-text {
		font-size: 14px;
		color: var(--text-secondary);
	}

	/* -- Empty state -------------------------------------------- */
	#empty-state {
		position: absolute;
		inset: 0;
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		gap: 12px;
		color: var(--text-dim);
		font-size: 13px;
		pointer-events: none;
	}

	#empty-state.hidden { display: none; }

	#empty-state svg { width: 40px; height: 40px; opacity: 0.3; }
	#empty-state .hint { font-size: 11px; opacity: 0.6; }

	/* -- Hidden file input -------------------------------------- */
	#file-input { display: none; }

	/* -- Layer selector ----------------------------------------- */
	#layer-select {
		background: var(--bg-tertiary);
		border: 1px solid var(--border);
		border-radius: 4px;
		color: var(--text-secondary);
		font-family: 'JetBrains Mono', monospace;
		font-size: 11px;
		padding: 4px 6px;
		cursor: pointer;
		outline: none;
	}

	#layer-select:focus { border-color: var(--accent-dim); }
</style>
</head>
<body>

<div id="app">
	<!-- Toolbar -->
	<div id="toolbar">
		<span class="logo">TR:GLYPH</span>
		<div class="separator"></div>

		<button class="tb-btn" id="btn-load" title="Load XML (Ctrl+O)">
			<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 15v4a2 2 0 002 2h14a2 2 0 002-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
			Load
		</button>

		<button class="tb-btn" id="btn-save" title="Save XML (Ctrl+S)">
			<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>
			Save
		</button>

		<div class="separator"></div>

		<div class="tb-group">
			<button class="tb-btn active" id="btn-filled" title="Filled preview">
				<svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="3" y="3" width="18" height="18" rx="2"/></svg>
				Filled
			</button>
			<button class="tb-btn" id="btn-outline" title="Outline preview">
				<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/></svg>
				Outline
			</button>
		</div>

		<div class="separator"></div>

		<button class="tb-btn active" id="btn-nodes" title="Toggle nodes/handles">
			<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><circle cx="4" cy="4" r="1.5"/><line x1="6" y1="6" x2="9.5" y2="9.5" stroke-dasharray="2 2"/></svg>
			Nodes
		</button>

		<button class="tb-btn active" id="btn-metrics" title="Toggle metrics">
			<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="4" y1="4" x2="4" y2="20"/><line x1="20" y1="4" x2="20" y2="20"/><line x1="4" y1="12" x2="20" y2="12" stroke-dasharray="3 2"/></svg>
			Metrics
		</button>

		<button class="tb-btn active" id="btn-anchors" title="Toggle anchors">
			<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L15 8H9L12 2Z"/><line x1="12" y1="8" x2="12" y2="18"/><circle cx="12" cy="20" r="2"/></svg>
			Anchors
		</button>

		<div class="separator"></div>

		<select id="layer-select" title="Layer"><option value="">-- no glyph --</option></select>

		<div class="separator"></div>

		<button class="tb-btn" id="btn-xml" title="Toggle XML panel (Ctrl+E)">
			<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>
			XML
		</button>

		<button class="tb-btn" id="btn-fit" title="Fit to view (Home)">
			<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 3h6v6"/><path d="M9 21H3v-6"/><path d="M21 3l-7 7"/><path d="M3 21l7-7"/></svg>
			Fit
		</button>

		<div class="tb-spacer"></div>

		<div id="glyph-info"></div>
	</div>

	<!-- Main -->
	<div id="main">
		<div id="canvas-wrap">
			<canvas id="glyph-canvas"></canvas>
			<div id="empty-state">
				<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="9" y1="15" x2="15" y2="15"/></svg>
				<span>Load a TypeRig glyph XML file</span>
				<span class="hint">Drop file here or use Load button</span>
			</div>
		</div>
		<div id="xml-panel">
			<div id="xml-panel-header">
				<span>XML Source</span>
				<span id="xml-node-count"></span>
			</div>
			<div id="xml-content"></div>
		</div>
	</div>

	<!-- Status bar -->
	<div id="statusbar">
		<div class="status-item">
			<span class="status-label">Zoom:</span>
			<span class="status-value" id="status-zoom">100%</span>
		</div>
		<div class="status-item">
			<span class="status-label">Cursor:</span>
			<span class="status-value" id="status-cursor">–</span>
		</div>
		<div class="status-item">
			<span class="status-label">Selected:</span>
			<span class="status-value" id="status-selected">–</span>
		</div>
	</div>
</div>

<!-- Drop overlay -->
<div id="drop-overlay">
	<div class="drop-icon">
		<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 15v4a2 2 0 002 2h14a2 2 0 002-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
	</div>
	<span class="drop-text">Drop TypeRig XML file</span>
</div>

<input type="file" id="file-input" accept=".xml,.typerig">

<script>
// ===================================================================
// TypeRig Glyph Viewer
// ===================================================================

(function() {
'use strict';

// -- State ----------------------------------------------------------
const state = {
	glyphData: null,       // parsed glyph object
	rawXml: '',            // raw XML string
	activeLayer: null,     // current layer name

	// View
	pan: { x: 0, y: 0 },
	zoom: 1,
	filled: true,
	showNodes: true,
	showMetrics: true,
	showAnchors: true,
	showXml: false,

	// Selection
	selectedNodeId: null,  // 'c{ci}_n{ni}' format

	// Interaction
	isPanning: false,
	lastMouse: { x: 0, y: 0 },
};

// -- DOM refs -------------------------------------------------------
const canvas = document.getElementById('glyph-canvas');
const ctx = canvas.getContext('2d');
const canvasWrap = document.getElementById('canvas-wrap');
const xmlContent = document.getElementById('xml-content');
const xmlNodeCount = document.getElementById('xml-node-count');
const mainEl = document.getElementById('main');
const emptyState = document.getElementById('empty-state');
const fileInput = document.getElementById('file-input');
const dropOverlay = document.getElementById('drop-overlay');
const layerSelect = document.getElementById('layer-select');
const glyphInfo = document.getElementById('glyph-info');
const statusZoom = document.getElementById('status-zoom');
const statusCursor = document.getElementById('status-cursor');
const statusSelected = document.getElementById('status-selected');

// -- XML Parser -----------------------------------------------------
function parseGlyphXML(xmlString) {
	const parser = new DOMParser();
	const doc = parser.parseFromString(xmlString, 'text/xml');
	const parseError = doc.querySelector('parsererror');
	if (parseError) throw new Error('XML parse error: ' + parseError.textContent);

	const glyphEl = doc.querySelector('glyph');
	if (!glyphEl) throw new Error('No <glyph> element found');

	const glyph = {
		name: glyphEl.getAttribute('name') || '',
		identifier: glyphEl.getAttribute('identifier') || '',
		unicodes: glyphEl.getAttribute('unicodes') || '',
		mark: parseInt(glyphEl.getAttribute('mark') || '0'),
		selected: glyphEl.getAttribute('selected') === 'True',
		layers: [],
	};

	for (const layerEl of glyphEl.querySelectorAll(':scope > layer')) {
		const layer = parseLayer(layerEl);
		glyph.layers.push(layer);
	}

	return glyph;
}

function parseLayer(el) {
	const layer = {
		name: el.getAttribute('name') || '',
		identifier: el.getAttribute('identifier') || '',
		width: parseFloat(el.getAttribute('width') || '0'),
		height: parseFloat(el.getAttribute('height') || '1000'),
		shapes: [],
		anchors: [],
		lib: {},
	};

	// Parse lib for stems, transform etc
	const libEl = el.querySelector(':scope > lib');
	if (libEl) {
		layer.lib = parsePlistDict(libEl.querySelector('dict'));
	}

	if (layer.lib.stx !== undefined) layer.stx = layer.lib.stx;
	if (layer.lib.sty !== undefined) layer.sty = layer.lib.sty;

	for (const shapeEl of el.querySelectorAll(':scope > shape')) {
		layer.shapes.push(parseShape(shapeEl));
	}

	// Parse anchors if present
	for (const anchorEl of el.querySelectorAll(':scope > anchor')) {
		layer.anchors.push({
			name: anchorEl.getAttribute('name') || '',
			x: parseFloat(anchorEl.getAttribute('x') || '0'),
			y: parseFloat(anchorEl.getAttribute('y') || '0'),
		});
	}

	return layer;
}

function parseShape(el) {
	const shape = {
		name: el.getAttribute('name') || '',
		identifier: el.getAttribute('identifier') || '',
		contours: [],
		lib: {},
	};

	const libEl = el.querySelector(':scope > lib');
	if (libEl) {
		shape.lib = parsePlistDict(libEl.querySelector('dict'));
	}

	for (const contourEl of el.querySelectorAll(':scope > contour')) {
		shape.contours.push(parseContour(contourEl));
	}

	return shape;
}

function parseContour(el) {
	const contour = {
		name: el.getAttribute('name') || '',
		identifier: el.getAttribute('identifier') || '',
		closed: true,
		clockwise: null,
		nodes: [],
		lib: {},
	};

	const libEl = el.querySelector(':scope > lib');
	if (libEl) {
		const libData = parsePlistDict(libEl.querySelector('dict'));
		if (libData.closed !== undefined) contour.closed = libData.closed;
		if (libData.clockwise !== undefined) contour.clockwise = libData.clockwise;
		contour.lib = libData;
	}

	for (const nodeEl of el.querySelectorAll(':scope > node')) {
		contour.nodes.push({
			x: parseFloat(nodeEl.getAttribute('x') || '0'),
			y: parseFloat(nodeEl.getAttribute('y') || '0'),
			type: nodeEl.getAttribute('type') || 'on',
			smooth: nodeEl.getAttribute('smooth') === 'True',
		});
	}

	return contour;
}

function parsePlistDict(dictEl) {
	if (!dictEl) return {};
	const result = {};
	const children = Array.from(dictEl.children);
	let i = 0;
	while (i < children.length) {
		if (children[i].tagName === 'key') {
			const key = children[i].textContent;
			i++;
			if (i < children.length) {
				result[key] = parsePlistValue(children[i]);
			}
		}
		i++;
	}
	return result;
}

function parsePlistValue(el) {
	switch (el.tagName) {
		case 'true': return true;
		case 'false': return false;
		case 'integer': return parseInt(el.textContent);
		case 'real': return parseFloat(el.textContent);
		case 'string': return el.textContent || '';
		case 'array': return Array.from(el.children).map(parsePlistValue);
		case 'dict': return parsePlistDict(el);
		default: return null;
	}
}

// -- Layer helpers ---------------------------------------------------
function getActiveLayer() {
	if (!state.glyphData) return null;
	const name = state.activeLayer;
	return state.glyphData.layers.find(l => l.name === name) || state.glyphData.layers[0] || null;
}

function getAllNodes(layer) {
	const nodes = [];
	if (!layer) return nodes;
	let ci = 0;
	for (const shape of layer.shapes) {
		for (const contour of shape.contours) {
			let ni = 0;
			for (const node of contour.nodes) {
				nodes.push({
					...node,
					id: `c${ci}_n${ni}`,
					contourIdx: ci,
					nodeIdx: ni,
					contour: contour,
				});
				ni++;
			}
			ci++;
		}
	}
	return nodes;
}

// -- Coordinate transforms ------------------------------------------
function glyphToScreen(gx, gy) {
	// Glyph Y is up, screen Y is down → flip
	return {
		x: gx * state.zoom + state.pan.x,
		y: -gy * state.zoom + state.pan.y,
	};
}

function screenToGlyph(sx, sy) {
	return {
		x: (sx - state.pan.x) / state.zoom,
		y: -(sy - state.pan.y) / state.zoom,
	};
}

// -- Drawing --------------------------------------------------------
function draw() {
	const dpr = window.devicePixelRatio || 1;
	const w = canvasWrap.clientWidth;
	const h = canvasWrap.clientHeight;

	canvas.width = w * dpr;
	canvas.height = h * dpr;
	canvas.style.width = w + 'px';
	canvas.style.height = h + 'px';
	ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

	// Clear
	ctx.fillStyle = state.filled ? '#18181b' : '#1a1a1e';
	ctx.fillRect(0, 0, w, h);

	const layer = getActiveLayer();
	if (!layer) return;

	// Draw metrics
	if (state.showMetrics) drawMetrics(layer, w, h);

	// Draw contours
	drawContours(layer);

	// Draw anchors
	if (state.showAnchors) drawAnchors(layer);

	// Draw nodes/handles
	if (state.showNodes) drawNodes(layer);
}

function drawMetrics(layer, w, h) {
	const advW = layer.width;
	const advH = layer.height;

	// Baseline (y=0)
	const baseY = glyphToScreen(0, 0).y;
	ctx.strokeStyle = var_baseline();
	ctx.lineWidth = 1;
	ctx.setLineDash([6, 4]);
	ctx.beginPath();
	ctx.moveTo(0, baseY);
	ctx.lineTo(w, baseY);
	ctx.stroke();
	ctx.setLineDash([]);

	// Advance height line (y=advH)
	const topY = glyphToScreen(0, advH).y;
	ctx.strokeStyle = var_baseline();
	ctx.setLineDash([6, 4]);
	ctx.beginPath();
	ctx.moveTo(0, topY);
	ctx.lineTo(w, topY);
	ctx.stroke();
	ctx.setLineDash([]);

	// LSB line (x=0)
	const lsbX = glyphToScreen(0, 0).x;
	ctx.strokeStyle = 'rgba(255,120,80,0.35)';
	ctx.lineWidth = 1;
	ctx.setLineDash([]);
	ctx.beginPath();
	ctx.moveTo(lsbX, 0);
	ctx.lineTo(lsbX, h);
	ctx.stroke();

	// RSB / Advance width line
	const rsbX = glyphToScreen(advW, 0).x;
	ctx.strokeStyle = 'rgba(91,157,239,0.45)';
	ctx.beginPath();
	ctx.moveTo(rsbX, 0);
	ctx.lineTo(rsbX, h);
	ctx.stroke();

	// Labels
	ctx.font = '10px "JetBrains Mono", monospace';

	// LSB label
	ctx.fillStyle = 'rgba(255,120,80,0.6)';
	ctx.textAlign = 'left';
	ctx.fillText('LSB (x=0)', lsbX + 4, baseY - 6);

	// RSB label
	ctx.fillStyle = 'rgba(91,157,239,0.7)';
	ctx.textAlign = 'right';
	ctx.fillText(`ADV (${advW})`, rsbX - 4, baseY - 6);

	// Baseline label
	ctx.fillStyle = 'rgba(255,120,80,0.5)';
	ctx.textAlign = 'left';
	ctx.fillText('Baseline', lsbX + 4, baseY + 14);

	// Height label
	ctx.fillStyle = 'rgba(255,120,80,0.5)';
	ctx.fillText(`Height (${advH})`, lsbX + 4, topY + 14);
}

function var_baseline() { return 'rgba(255,120,80,0.25)'; }

function drawContours(layer) {
	for (const shape of layer.shapes) {
		for (const contour of shape.contours) {
			drawContour(contour);
		}
	}
}

function drawContour(contour) {
	if (contour.nodes.length === 0) return;

	ctx.beginPath();
	buildContourPath(contour);

	if (state.filled) {
		ctx.fillStyle = 'rgba(200,200,210,0.12)';
		ctx.fill('evenodd');
		ctx.strokeStyle = 'rgba(200,200,210,0.6)';
		ctx.lineWidth = 1;
		ctx.stroke();
	} else {
		ctx.strokeStyle = '#c8c8d2';
		ctx.lineWidth = 1.5;
		ctx.stroke();
	}
}

function buildContourPath(contour) {
	const nodes = contour.nodes;
	if (nodes.length === 0) return;

	// Build segments from node list
	// Types: 'on' = on-curve, 'curve' = cubic BCP, 'off' = quadratic off-curve
	let i = 0;
	const n = nodes.length;

	// Find first on-curve
	let firstOn = 0;
	for (let j = 0; j < n; j++) {
		if (nodes[j].type === 'on') { firstOn = j; break; }
	}

	const sp = glyphToScreen(nodes[firstOn].x, nodes[firstOn].y);
	ctx.moveTo(sp.x, sp.y);

	i = (firstOn + 1) % n;
	let count = 0;

	while (count < n - 1) {
		const node = nodes[i];

		if (node.type === 'on') {
			// Line to
			const p = glyphToScreen(node.x, node.y);
			ctx.lineTo(p.x, p.y);

		} else if (node.type === 'curve') {
			// Cubic: expect two BCPs then an on-curve
			const bcp1 = node;
			const bcp2 = nodes[(i + 1) % n];
			const onCurve = nodes[(i + 2) % n];
			const p1 = glyphToScreen(bcp1.x, bcp1.y);
			const p2 = glyphToScreen(bcp2.x, bcp2.y);
			const p3 = glyphToScreen(onCurve.x, onCurve.y);
			ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
			i = (i + 2) % n;
			count += 2;

		} else if (node.type === 'off') {
			// Quadratic: single off-curve then on-curve
			const offNode = node;
			const onCurve = nodes[(i + 1) % n];
			const p1 = glyphToScreen(offNode.x, offNode.y);
			const p2 = glyphToScreen(onCurve.x, onCurve.y);
			ctx.quadraticCurveTo(p1.x, p1.y, p2.x, p2.y);
			i = (i + 1) % n;
			count += 1;
		}

		i = (i + 1) % n;
		count++;
	}

	if (contour.closed) ctx.closePath();
}

function drawNodes(layer) {
	// First pass: draw handle lines
	let ci = 0;
	for (const shape of layer.shapes) {
		for (const contour of shape.contours) {
			const nodes = contour.nodes;
			const n = nodes.length;

			for (let ni = 0; ni < n; ni++) {
				const node = nodes[ni];
				if (node.type === 'curve' || node.type === 'off') {
					// Find the parent on-curve
					const sp = glyphToScreen(node.x, node.y);

					// Look backward for on-curve
					let prevIdx = (ni - 1 + n) % n;
					if (nodes[prevIdx].type === 'on' || nodes[prevIdx].type === 'curve') {
						const pp = glyphToScreen(nodes[prevIdx].x, nodes[prevIdx].y);
						ctx.strokeStyle = 'rgba(91,157,239,0.35)';
						ctx.lineWidth = 1;
						ctx.beginPath();
						ctx.moveTo(pp.x, pp.y);
						ctx.lineTo(sp.x, sp.y);
						ctx.stroke();
					}

					// Look forward for on-curve
					let nextIdx = (ni + 1) % n;
					if (nodes[nextIdx].type === 'on') {
						const np = glyphToScreen(nodes[nextIdx].x, nodes[nextIdx].y);
						ctx.strokeStyle = 'rgba(91,157,239,0.35)';
						ctx.lineWidth = 1;
						ctx.beginPath();
						ctx.moveTo(sp.x, sp.y);
						ctx.lineTo(np.x, np.y);
						ctx.stroke();
					}
				}
			}
			ci++;
		}
	}

	// Second pass: draw node markers
	ci = 0;
	for (const shape of layer.shapes) {
		for (const contour of shape.contours) {
			const nodes = contour.nodes;
			for (let ni = 0; ni < nodes.length; ni++) {
				const node = nodes[ni];
				const id = `c${ci}_n${ni}`;
				const sp = glyphToScreen(node.x, node.y);
				const isSelected = state.selectedNodeId === id;
				const r = isSelected ? 5 : (node.type === 'on' ? 4 : 3);

				if (node.type === 'on') {
					// On-curve: square for corner, round for smooth
					ctx.fillStyle = isSelected ? '#ff6b6b' : (node.smooth ? '#50c878' : '#e8e8ec');
					ctx.strokeStyle = isSelected ? '#ff6b6b' : 'rgba(0,0,0,0.5)';
					ctx.lineWidth = 1;

					if (node.smooth) {
						ctx.beginPath();
						ctx.arc(sp.x, sp.y, r, 0, Math.PI * 2);
						ctx.fill();
						ctx.stroke();
					} else {
						ctx.fillRect(sp.x - r, sp.y - r, r * 2, r * 2);
						ctx.strokeRect(sp.x - r, sp.y - r, r * 2, r * 2);
					}
				} else {
					// Off-curve: small circle
					ctx.fillStyle = isSelected ? '#ff6b6b' : '#5b9def';
					ctx.strokeStyle = isSelected ? '#ff6b6b' : 'rgba(0,0,0,0.5)';
					ctx.lineWidth = 1;
					ctx.beginPath();
					ctx.arc(sp.x, sp.y, r, 0, Math.PI * 2);
					ctx.fill();
					ctx.stroke();
				}
			}
			ci++;
		}
	}
}

function drawAnchors(layer) {
	if (!layer.anchors || layer.anchors.length === 0) return;

	for (const anchor of layer.anchors) {
		const sp = glyphToScreen(anchor.x, anchor.y);
		const size = 6;

		// Diamond shape
		ctx.fillStyle = '#ff6b6b';
		ctx.strokeStyle = 'rgba(0,0,0,0.5)';
		ctx.lineWidth = 1;
		ctx.beginPath();
		ctx.moveTo(sp.x, sp.y - size);
		ctx.lineTo(sp.x + size, sp.y);
		ctx.lineTo(sp.x, sp.y + size);
		ctx.lineTo(sp.x - size, sp.y);
		ctx.closePath();
		ctx.fill();
		ctx.stroke();

		// Crosshair
		ctx.strokeStyle = 'rgba(255,107,107,0.4)';
		ctx.setLineDash([3, 3]);
		ctx.beginPath();
		ctx.moveTo(sp.x - 12, sp.y);
		ctx.lineTo(sp.x + 12, sp.y);
		ctx.moveTo(sp.x, sp.y - 12);
		ctx.lineTo(sp.x, sp.y + 12);
		ctx.stroke();
		ctx.setLineDash([]);

		// Label
		ctx.font = '10px "JetBrains Mono", monospace';
		ctx.fillStyle = 'rgba(255,107,107,0.8)';
		ctx.textAlign = 'left';
		ctx.fillText(anchor.name, sp.x + size + 4, sp.y + 3);
	}
}

// -- Hit test -------------------------------------------------------
function hitTestNode(sx, sy, radius) {
	const layer = getActiveLayer();
	if (!layer) return null;

	const r2 = (radius || 8) * (radius || 8);
	const allNodes = getAllNodes(layer);

	let closest = null;
	let closestDist = Infinity;

	for (const node of allNodes) {
		const sp = glyphToScreen(node.x, node.y);
		const dx = sp.x - sx;
		const dy = sp.y - sy;
		const d2 = dx * dx + dy * dy;
		if (d2 < r2 && d2 < closestDist) {
			closestDist = d2;
			closest = node;
		}
	}

	return closest;
}

// -- XML Panel ------------------------------------------------------
function buildXmlPanel() {
	if (!state.rawXml) {
		xmlContent.innerHTML = '';
		xmlNodeCount.textContent = '';
		return;
	}

	// Pretty-print the XML
	const formatted = formatXml(state.rawXml);
	const lines = formatted.split('\n');

	// Build node ID mapping: line index → node id
	// We track which lines contain <node> elements and map them
	const lineMap = buildLineNodeMap(formatted);

	let html = '';
	for (let i = 0; i < lines.length; i++) {
		const line = lines[i];
		const nodeId = lineMap[i] || null;
		const clickable = nodeId ? ' clickable' : '';
		const dataAttr = nodeId ? ` data-node-id="${nodeId}"` : '';
		html += `<span class="xml-line${clickable}" data-line="${i}"${dataAttr}>${highlightXmlLine(escapeHtml(line))}</span>\n`;
	}

	xmlContent.innerHTML = html;

	// Count nodes
	const layer = getActiveLayer();
	if (layer) {
		const allNodes = getAllNodes(layer);
		const onCount = allNodes.filter(n => n.type === 'on').length;
		const offCount = allNodes.length - onCount;
		xmlNodeCount.textContent = `${onCount} on / ${offCount} off`;
	}

	// Attach click listeners to node lines
	for (const el of xmlContent.querySelectorAll('.xml-line.clickable')) {
		el.addEventListener('click', () => {
			const nodeId = el.dataset.nodeId;
			selectNode(nodeId);
		});
	}
}

function buildLineNodeMap(formatted) {
	const lines = formatted.split('\n');
	const map = {};

	// Track contour index globally across all shapes
	let globalContourIdx = 0;
	let nodeIdx = 0;
	let inContour = false;

	for (let i = 0; i < lines.length; i++) {
		const line = lines[i].trim();

		if (line.startsWith('<contour')) {
			inContour = true;
			nodeIdx = 0;
		} else if (line === '</contour>') {
			if (inContour) globalContourIdx++;
			inContour = false;
		} else if (inContour && line.startsWith('<node ')) {
			map[i] = `c${globalContourIdx}_n${nodeIdx}`;
			nodeIdx++;
		}
	}

	return map;
}

function formatXml(xml) {
	// Simple XML formatter
	let result = '';
	let indent = 0;
	const tab = '  ';

	// Normalize
	xml = xml.replace(/>\s*</g, '><').trim();

	const tokens = xml.match(/<[^>]+>|[^<]+/g) || [];

	for (const token of tokens) {
		if (token.startsWith('</')) {
			// Closing tag
			indent--;
			result += tab.repeat(Math.max(0, indent)) + token + '\n';
		} else if (token.startsWith('<') && token.endsWith('/>')) {
			// Self-closing
			result += tab.repeat(indent) + token + '\n';
		} else if (token.startsWith('<')) {
			// Opening tag
			result += tab.repeat(indent) + token + '\n';
			indent++;
		} else {
			// Text content
			const trimmed = token.trim();
			if (trimmed) result += tab.repeat(indent) + trimmed + '\n';
		}
	}

	return result.trimEnd();
}

function escapeHtml(s) {
	return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

function highlightXmlLine(line) {
	// Syntax-highlight an already-escaped XML line
	return line
		// Tag names: <tagname or </tagname
		.replace(/(&lt;\/?)([\w:-]+)/g, '<span class="xp">$1</span><span class="xt">$2</span>')
		// Self-closing and closing brackets
		.replace(/(\/?&gt;)/g, '<span class="xp">$1</span>')
		// Attributes: name="value"
		.replace(/([\w:-]+)(=)(&quot;)([^&]*?)(&quot;)/g,
			'<span class="xa">$1</span><span class="xp">$2</span><span class="xv">$3$4$5</span>');
}

function highlightXmlNode(nodeId) {
	// Clear previous
	for (const el of xmlContent.querySelectorAll('.xml-line.highlighted')) {
		el.classList.remove('highlighted');
	}

	if (!nodeId) return;

	const el = xmlContent.querySelector(`.xml-line[data-node-id="${nodeId}"]`);
	if (el) {
		el.classList.add('highlighted');
		el.scrollIntoView({ behavior: 'smooth', block: 'center' });
	}
}

// -- Selection ------------------------------------------------------
function selectNode(nodeId) {
	state.selectedNodeId = nodeId;
	highlightXmlNode(nodeId);
	draw();
	updateStatusSelected();
}

function updateStatusSelected() {
	if (!state.selectedNodeId) {
		statusSelected.textContent = '–';
		return;
	}

	const layer = getActiveLayer();
	if (!layer) return;

	const allNodes = getAllNodes(layer);
	const node = allNodes.find(n => n.id === state.selectedNodeId);
	if (node) {
		statusSelected.textContent = `${node.type} (${node.x}, ${node.y})${node.smooth ? ' smooth' : ''}`;
	}
}

// -- Fit to view ----------------------------------------------------
function fitToView() {
	const layer = getActiveLayer();
	if (!layer) return;

	const w = canvasWrap.clientWidth;
	const h = canvasWrap.clientHeight;

	// Compute bounds from advance width/height and actual contour bounds
	let minX = 0, minY = 0;
	let maxX = layer.width || 0;
	let maxY = layer.height || 1000;

	for (const shape of layer.shapes) {
		for (const contour of shape.contours) {
			for (const node of contour.nodes) {
				minX = Math.min(minX, node.x);
				minY = Math.min(minY, node.y);
				maxX = Math.max(maxX, node.x);
				maxY = Math.max(maxY, node.y);
			}
		}
	}

	// Add anchors to bounds
	if (layer.anchors) {
		for (const a of layer.anchors) {
			minX = Math.min(minX, a.x);
			minY = Math.min(minY, a.y);
			maxX = Math.max(maxX, a.x);
			maxY = Math.max(maxY, a.y);
		}
	}

	const glyphW = maxX - minX || 1;
	const glyphH = maxY - minY || 1;

	const padding = 60;
	const scaleX = (w - padding * 2) / glyphW;
	const scaleY = (h - padding * 2) / glyphH;
	state.zoom = Math.min(scaleX, scaleY);

	// Center: glyph center in screen coords
	const cx = (minX + maxX) / 2;
	const cy = (minY + maxY) / 2;
	state.pan.x = w / 2 - cx * state.zoom;
	state.pan.y = h / 2 + cy * state.zoom; // flip Y

	updateZoomStatus();
	draw();
}

function updateZoomStatus() {
	statusZoom.textContent = Math.round(state.zoom * 100) + '%';
}

// -- File I/O -------------------------------------------------------
function loadXmlString(xmlString, filename) {
	try {
		state.glyphData = parseGlyphXML(xmlString);
		state.rawXml = xmlString;

		// Populate layer selector
		layerSelect.innerHTML = '';
		for (const layer of state.glyphData.layers) {
			const opt = document.createElement('option');
			opt.value = layer.name;
			opt.textContent = layer.name || '(unnamed)';
			layerSelect.appendChild(opt);
		}

		if (state.glyphData.layers.length > 0) {
			state.activeLayer = state.glyphData.layers[0].name;
			layerSelect.value = state.activeLayer;
		}

		// Update info
		const g = state.glyphData;
		let infoHtml = `<span>${g.name || '?'}</span>`;
		if (g.unicodes) infoHtml += ` U+${g.unicodes}`;
		glyphInfo.innerHTML = infoHtml;

		emptyState.classList.add('hidden');
		state.selectedNodeId = null;

		fitToView();
		buildXmlPanel();
	} catch (e) {
		alert('Error loading XML: ' + e.message);
	}
}

function saveXml() {
	if (!state.rawXml) return;

	const blob = new Blob([state.rawXml], { type: 'application/xml' });
	const url = URL.createObjectURL(blob);
	const a = document.createElement('a');
	a.href = url;
	const name = state.glyphData ? state.glyphData.name : 'glyph';
	a.download = `${name}.xml`;
	a.click();
	URL.revokeObjectURL(url);
}

// -- Event handlers -------------------------------------------------

// Pan and zoom
canvasWrap.addEventListener('mousedown', (e) => {
	if (e.button === 0) {
		// Check if clicking on a node first
		if (state.showNodes) {
			const rect = canvas.getBoundingClientRect();
			const sx = e.clientX - rect.left;
			const sy = e.clientY - rect.top;
			const hit = hitTestNode(sx, sy);
			if (hit) {
				selectNode(hit.id);
				return;
			}
		}
		// Otherwise, start panning
		state.isPanning = true;
		state.lastMouse = { x: e.clientX, y: e.clientY };
		selectNode(null);
	}
});

window.addEventListener('mousemove', (e) => {
	// Update cursor position
	const rect = canvas.getBoundingClientRect();
	const sx = e.clientX - rect.left;
	const sy = e.clientY - rect.top;
	const gp = screenToGlyph(sx, sy);
	statusCursor.textContent = `${Math.round(gp.x)}, ${Math.round(gp.y)}`;

	if (state.isPanning) {
		const dx = e.clientX - state.lastMouse.x;
		const dy = e.clientY - state.lastMouse.y;
		state.pan.x += dx;
		state.pan.y += dy;
		state.lastMouse = { x: e.clientX, y: e.clientY };
		draw();
	}
});

window.addEventListener('mouseup', () => {
	state.isPanning = false;
});

canvasWrap.addEventListener('wheel', (e) => {
	e.preventDefault();
	const rect = canvas.getBoundingClientRect();
	const mx = e.clientX - rect.left;
	const my = e.clientY - rect.top;

	const factor = e.deltaY > 0 ? 0.9 : 1.1;
	const newZoom = state.zoom * factor;

	// Zoom toward cursor
	state.pan.x = mx - (mx - state.pan.x) * (newZoom / state.zoom);
	state.pan.y = my - (my - state.pan.y) * (newZoom / state.zoom);
	state.zoom = newZoom;

	updateZoomStatus();
	draw();
}, { passive: false });

// Resize
const resizeObserver = new ResizeObserver(() => { draw(); });
resizeObserver.observe(canvasWrap);

// Toolbar buttons
document.getElementById('btn-load').addEventListener('click', () => fileInput.click());
document.getElementById('btn-save').addEventListener('click', saveXml);

document.getElementById('btn-filled').addEventListener('click', function() {
	state.filled = true;
	this.classList.add('active');
	document.getElementById('btn-outline').classList.remove('active');
	draw();
});

document.getElementById('btn-outline').addEventListener('click', function() {
	state.filled = false;
	this.classList.add('active');
	document.getElementById('btn-filled').classList.remove('active');
	draw();
});

document.getElementById('btn-nodes').addEventListener('click', function() {
	state.showNodes = !state.showNodes;
	this.classList.toggle('active');
	draw();
});

document.getElementById('btn-metrics').addEventListener('click', function() {
	state.showMetrics = !state.showMetrics;
	this.classList.toggle('active');
	draw();
});

document.getElementById('btn-anchors').addEventListener('click', function() {
	state.showAnchors = !state.showAnchors;
	this.classList.toggle('active');
	draw();
});

document.getElementById('btn-xml').addEventListener('click', function() {
	state.showXml = !state.showXml;
	this.classList.toggle('active');
	mainEl.classList.toggle('split', state.showXml);
	requestAnimationFrame(() => {
		draw();
		if (state.showXml) buildXmlPanel();
	});
});

document.getElementById('btn-fit').addEventListener('click', fitToView);

layerSelect.addEventListener('change', function() {
	state.activeLayer = this.value;
	state.selectedNodeId = null;
	fitToView();
	buildXmlPanel();
});

// File input
fileInput.addEventListener('change', (e) => {
	const file = e.target.files[0];
	if (!file) return;
	const reader = new FileReader();
	reader.onload = (ev) => loadXmlString(ev.target.result, file.name);
	reader.readAsText(file);
	fileInput.value = '';
});

// Drag and drop
document.addEventListener('dragover', (e) => {
	e.preventDefault();
	dropOverlay.classList.add('visible');
});

document.addEventListener('dragleave', (e) => {
	if (e.relatedTarget === null || !document.contains(e.relatedTarget)) {
		dropOverlay.classList.remove('visible');
	}
});

document.addEventListener('drop', (e) => {
	e.preventDefault();
	dropOverlay.classList.remove('visible');
	const file = e.dataTransfer.files[0];
	if (!file) return;
	const reader = new FileReader();
	reader.onload = (ev) => loadXmlString(ev.target.result, file.name);
	reader.readAsText(file);
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
	if (e.ctrlKey || e.metaKey) {
		if (e.key === 'o') { e.preventDefault(); fileInput.click(); }
		if (e.key === 's') { e.preventDefault(); saveXml(); }
		if (e.key === 'e') {
			e.preventDefault();
			document.getElementById('btn-xml').click();
		}
	}
	if (e.key === 'Home') { e.preventDefault(); fitToView(); }
	if (e.key === 'Escape') { selectNode(null); }
});

// -- Load sample on start -------------------------------------------
// Provide a sample glyph so the viewer isn't empty on first load
function loadSampleGlyph() {
	const sampleXml = `<?xml version="1.0" encoding="UTF-8"?>
<glyph name="A" unicodes="0041" mark="0">
  <layer name="Regular" width="680" height="700">
    <shape name="main">
      <contour>
        <node x="340" y="700" type="on"/>
        <node x="20" y="0" type="on"/>
        <node x="120" y="0" type="on"/>
        <node x="197" y="200" type="on"/>
        <node x="483" y="200" type="on"/>
        <node x="560" y="0" type="on"/>
        <node x="660" y="0" type="on"/>
        <lib>
          <dict>
            <key>closed</key>
            <true/>
          </dict>
        </lib>
      </contour>
      <contour>
        <node x="222" y="270" type="on"/>
        <node x="340" y="580" type="on"/>
        <node x="458" y="270" type="on"/>
        <lib>
          <dict>
            <key>closed</key>
            <true/>
          </dict>
        </lib>
      </contour>
    </shape>
    <shape name="crossbar">
      <contour>
        <node x="170" y="310" type="on"/>
        <node x="510" y="310" type="on"/>
        <node x="490" y="380" type="on"/>
        <node x="190" y="380" type="on"/>
        <lib>
          <dict>
            <key>closed</key>
            <true/>
          </dict>
        </lib>
      </contour>
    </shape>
    <anchor name="top" x="340" y="710"/>
    <anchor name="bottom" x="340" y="-10"/>
    <lib>
      <dict>
        <key>stx</key>
        <integer>90</integer>
        <key>sty</key>
        <integer>80</integer>
      </dict>
    </lib>
  </layer>
  <layer name="Bold" width="750" height="700">
    <shape name="main">
      <contour>
        <node x="375" y="700" type="on"/>
        <node x="10" y="0" type="on"/>
        <node x="150" y="0" type="on"/>
        <node x="235" y="200" type="on"/>
        <node x="515" y="200" type="on"/>
        <node x="600" y="0" type="on"/>
        <node x="740" y="0" type="on"/>
        <lib>
          <dict>
            <key>closed</key>
            <true/>
          </dict>
        </lib>
      </contour>
      <contour>
        <node x="267" y="275" type="on"/>
        <node x="375" y="545" type="on"/>
        <node x="483" y="275" type="on"/>
        <lib>
          <dict>
            <key>closed</key>
            <true/>
          </dict>
        </lib>
      </contour>
    </shape>
    <shape name="crossbar">
      <contour>
        <node x="200" y="310" type="on"/>
        <node x="550" y="310" type="on"/>
        <node x="520" y="400" type="on"/>
        <node x="230" y="400" type="on"/>
        <lib>
          <dict>
            <key>closed</key>
            <true/>
          </dict>
        </lib>
      </contour>
    </shape>
    <anchor name="top" x="375" y="710"/>
    <anchor name="bottom" x="375" y="-10"/>
    <lib>
      <dict>
        <key>stx</key>
        <integer>140</integer>
        <key>sty</key>
        <integer>120</integer>
      </dict>
    </lib>
  </layer>
</glyph>`;

	loadXmlString(sampleXml, 'sample_A.xml');
}

// -- Init -----------------------------------------------------------
loadSampleGlyph();

})();
</script>
</body>
</html>
